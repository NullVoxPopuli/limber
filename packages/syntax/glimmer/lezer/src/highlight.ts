import { styleTags, tags as t } from '@lezer/highlight';

export const svelteHighlighting = styleTags({
  Comment: t.blockComment,
  MoustacheComment: t.blockComment,
  LongMoustacheComment: t.blockComment,
  ///////////////////////
  // TODO: need to verify
  Splattributes: t.derefOperator,
  ArgName: t.attributeName,
  Argument: t.propertyName,
  NamedBlock: t.tagName,
  Pipe: t.definitionOperator,

  as: t.definitionOperator,
  let: t.function(t.definitionOperator),
  this: t.self,
  yield: t.operatorKeyword,
  outlet: t.operatorKeyword,

  component: t.function(t.definitionKeyword),
  modifier: t.function(t.definitionKeyword),
  helper: t.function(t.definitionKeyword),
  hash: t.function(t.definitionKeyword),
  array: t.function(t.definitionKeyword),
  on: t.function(t.definitionKeyword),
  concat: t.function(t.operatorKeyword),
  // 'if then catch unless else each each-in': t.controlKeyword,
  ///////////////////////
  // TODO: is nededed?
  'Text RawText': t.content,
  'StartTag StartCloseTag SelfClosingEndTag EndTag': t.angleBracket,
  TagName: t.tagName,
  'MismatchedCloseTag/TagName': [t.tagName, t.invalid],
  AttributeName: t.attributeName,
  UnquotedAttributeValue: t.attributeValue,
  'DoubleQuote SingleQuote AttributeValueContent': t.attributeValue,
  Is: t.definitionOperator,
  'EntityReference CharacterReference': t.character,
  ProcessingInst: t.processingInstruction,
  DoctypeDecl: t.documentMeta,
  '{ }': t.bracket,
  '[ ]': t.squareBracket,
  '( )': t.paren,
  '| , :': t.punctuation,
  '...': t.derefOperator,
  ComponentName: t.className,
  SvelteElementNamespace: t.namespace,
  SvelteElementType: t.tagName,
  StyleAttributeName: t.propertyName,
  BlockType: t.controlKeyword,
  BlockPrefix: t.typeOperator,
  'UnknownBlock/BlockType': t.invalid,
  UnknownBlockContent: t.invalid,
  'if then catch': t.controlKeyword,
  Variable: t.variableName,
  Modifier: t.modifier,
  DirectlyInterpolatedAttributeValue: t.attributeValue,
  'DirectiveOn/DirectiveName': t.controlKeyword,
  'DirectiveOn/DirectiveTarget': t.typeName,
  'DirectiveUse/DirectiveName': t.controlKeyword,
  'DirectiveUse/DirectiveTarget': t.function(t.variableName),
  'DirectiveBind/DirectiveName': t.controlKeyword,
  'DirectiveBind/DirectiveTarget': t.variableName,
  'DirectiveLet/DirectiveName': t.definitionKeyword,
  'DirectiveLet/DirectiveTarget': t.definition(t.variableName),
  'DirectiveTransition/DirectiveName': t.operatorKeyword,
  'DirectiveTransition/DirectiveTarget': t.function(t.variableName),
  'DirectiveIn/DirectiveName': t.operatorKeyword,
  'DirectiveIn/DirectiveTarget': t.function(t.variableName),
  'DirectiveOut/DirectiveName': t.operatorKeyword,
  'DirectiveOut/DirectiveTarget': t.function(t.variableName),
  'DirectiveAnimate/DirectiveName': t.operatorKeyword,
  'DirectiveAnimate/DirectiveTarget': t.function(t.variableName),
  'DirectiveClass/DirectiveName': t.attributeName,
  'DirectiveClass/DirectiveTarget': t.variableName,
  'DirectiveStyle/DirectiveName': t.attributeName,
  'DirectiveStyle/DirectiveTarget': t.propertyName,
});
