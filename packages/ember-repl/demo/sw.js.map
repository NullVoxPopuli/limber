{"version":3,"file":"sw.js","sources":["src/compiler/fetch-handler.ts","src/compiler/sw.ts"],"sourcesContent":["const PREFIX_PROXY_MODULE = '/proxy-module/';\n\n// const CACHE_NAME = 'babel-compilation-and-module-service';\nconst URLS = ['/compile.sw', '/module.sw'];\n\nconst COMPILE_CACHE = new Map();\n\nexport async function handleFetch(event: FetchEvent): Promise<Response> {\n  // event.request.url is a string\n  const url = new URL(event.request.url);\n\n  /**\n    * We only define two URL handlers,\n    * - compile.sw - actually does compilation\n    * - module.sw - loads what we compiled\n    */\n  if (!URLS.some((matcher) => url.pathname.startsWith(matcher))) {\n    return fetch(event.request);\n  }\n\n  if (COMPILE_CACHE.has(url.pathname)) {\n    return moduleResponse(url.pathname);\n  }\n\n  if (url.pathname === '/compile.sw') {\n    return maybe(() => compile(event.request));\n  }\n\n  return error(`Unhandled URL: ${url.pathname}`);\n}\n\nasync function maybe<Return>(op: () => Return | Promise<Return>) {\n  try {\n    return await op();\n  } catch (e) {\n    return error(e);\n  }\n}\n\nfunction error(msg: unknown | string, status = 500) {\n  let payload: string | Error | Record<string, unknown>;\n\n  if (typeof msg === 'string') {\n    payload = msg;\n  } else if (msg instanceof TypeError) {\n    payload = {\n      ...msg,\n      name: msg.name,\n      message: msg.message,\n      stack: msg.stack,\n    };\n  } else {\n    payload = msg;\n  }\n\n  return new Response(JSON.stringify({ error: payload }), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n\nfunction moduleResponse(pathName: string) {\n  let code = COMPILE_CACHE.get(pathName);\n\n  if (!code) {\n    throw new Error(`Code has not been compiled. call /compile.sw with the code`);\n  }\n\n  return new Response(code, {\n    headers: {\n      'Content-Type': 'application/javascript',\n    },\n  });\n}\n\nasync function compile(request: Request) {\n  let body = await request.json();\n\n  console.log(body);\n\n  let { code, format } = body;\n\n  if (!code) {\n    throw new Error(`'code' property missing in body`);\n  }\n\n  if (!format) {\n    throw new Error(`'format' property missing in body`);\n  }\n\n  let name = 'test-todo-generate-from-code';\n\n  let modulePath = `/module.sw/${name}.js`;\n\n  // TODO: all external imports must be changed \n  //       (via babel plugin (because we already have babel))\n  //       to use https://esm.sh/*thePackage\n  //\n  // let compiled = await compileGJS({ name, code });\n\n  // COMPILE_CACHE.set(modulePath, compiled);\n  COMPILE_CACHE.set(modulePath, code);\n\n  let response = new Response(JSON.stringify({\n    importPath: modulePath,\n    content: code,\n  }), {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  return response;\n}\n","import { handleFetch } from './fetch-handler.ts';\n\n// Silly Workers\nexport type { };\ndeclare const self: ServiceWorkerGlobalScope;\n\n/**\n * For a given markdown document id, we will compile\n * N components within that glimdown, and return an object\n * map of an arbitrary name of the default export to the URL\n * for which the module may be imported from.\n *\n * Since the set of modules is uniqueish to the glimdown\n * document id, we'll try to keep a history of 10 most recent\n * compiles, so that quick edits don't need to do extra work\n *\n * example:\n *\n *  POST /compile.sw\n *    id: gmd.id,\n *    components: [{ name: string, code: string }]\n *\n *   =>\n *\n *  {\n *    [name] => \"url/to/import\"\n *  }\n *\n *\n */\nself.addEventListener('install', () => {\n  // force moving on to activation even if another service worker had control\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', (event) => {\n  // Claim any clients immediately, so that the page will be under SW control without reloading.\n  const claim = self.clients.claim();\n  event.waitUntil(claim);\n\n  console.info(`\\\n    Service Worker installed successfully!\n\n    This service worker is used for compiling JavaScript\n    and providing modules to the main thread.\n  `);\n});\n\n\nself.addEventListener(\"fetch\", (event) => {\n  event.respondWith(handleFetch(event));\n});\n\n"],"names":["URLS","COMPILE_CACHE","Map","handleFetch","event","url","URL","request","some","matcher","pathname","startsWith","fetch","has","moduleResponse","maybe","compile","error","op","e","msg","status","payload","TypeError","name","message","stack","Response","JSON","stringify","headers","pathName","code","get","Error","body","json","console","log","format","modulePath","set","response","importPath","content","self","addEventListener","skipWaiting","claim","clients","waitUntil","info","respondWith"],"mappings":"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"}